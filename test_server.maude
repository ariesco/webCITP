  ---- from the book All About Maude
  ---- from the Maude Manual
  ---- by the Maude team

  load socket.maude

  mod FACTORIAL-SERVER is
    inc SOCKET .
    pr CONVERSION .

    op _! : Nat -> NzNat .
    eq 0 ! = 1 .
    eq (s N) ! = (s N) * (N !) .

    op Server : -> Cid .
    op aServer : -> Oid .

    vars O LISTENER CLIENT : Oid .
    var  A : AttributeSet .
    vars N N' N'' : Nat .
    vars IP DATA S S' : String .

    op magic : -> String .
    eq magic = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" .

    op secField : -> String .
    eq secField = "Sec-WebSocket-Key: " .

    op websocketAnswer : String -> String .
    ceq websocketAnswer(S) = S'
     if N := find(S, secField, 0) /\
        N' := find(S, "\r\n", N) /\
        N'' := N + length(secField) /\
        S' := substr(S, N'', sd(N', N'')) + magic .

    ***(
     The Sec-WebSocket-Accept part is interesting.
     To get it, concatenate the client's Sec-WebSocket-Key
     and "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" together (it's a "magic string"), take
     the SHA-1 hash of the result, and return the base64 encoding of the hash.
    )

    op ans : -> String .
    eq ans = "HTTP/1.1 101 Switching Protocols\r\n" +
             "Upgrade: websocket\r\n" +
             "Connection: Upgrade\r\n" +
             "Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\r\n\r\n" .

    op done : String -> Msg [ctor] .

    rl [createdSocket] :
      < O : Server | A > createdSocket(O, socketManager, LISTENER)
      => < O : Server | A > acceptClient(LISTENER, O) .

    rl [acceptedClient] :
      < O : Server | A > acceptedClient(O, LISTENER, IP, CLIENT)
      => < O : Server | A > receive(CLIENT, O)
         send(CLIENT, O, ans)
         acceptClient(LISTENER, O)
         done("Aceptado") .

    crl [received] :
        received(O, CLIENT, DATA)
        < O : Server | A >
     => < O : Server | A >
        send(CLIENT, O, S)
        receive(CLIENT, O)
        done("Recibido")
     if S := string(rat(DATA, 10)!, 10) + "\r\n\r\n" .


    crl [received] :
        received(O, CLIENT, DATA)
        < O : Server | A >
     => < O : Server | A >
        send(CLIENT, O, "Hola\r\n\r\n")
        receive(CLIENT, O)
        done("Saludado a " + DATA)
     if not (string(rat(DATA, 10)!, 10) :: String) .

***    rl [sent] :
***      < O : Server | A > sent(O, CLIENT)
***      => < O : Server | A > closeSocket(CLIENT, O) .

    rl [closedSocket] :
      < O : Server | A > closedSocket(O, CLIENT, S)
      => < O : Server | A > .
  endm

*** set trace on .

red websocketAnswer("GET / HTTP/1.1\r\nHost: 147.96.81.57:8811\r\nConnection: Upgrade\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade: websocket\r\nOrigin: file://\r\nSec-WebSocket-Version: 13\r\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.115 Safari/537.36\r\nAccept-Encoding: gzip, deflate\r\nAccept-Language: es,en;q=0.8,ja;q=0.6,en-US;q=0.4\r\nSec-WebSocket-Key: u42PRo0VsWTmHuhK55qJ9A==\r\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n\r\n") .

*** u42PRo0VsWTmHuhK55qJ9A==

erew <> < aServer : Server | none >
        createServerTcpSocket(socketManager, aServer, 8811, 5) .
